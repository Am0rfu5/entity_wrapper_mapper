<?php
/**
 * @file
 * Module to create and use Microsite entities.
 */

/**
 * Implements hook_entity_info().
 */
function microsite_entity_entity_info() {
  $return = array(
    'microsite_entity' => array(
      'label' => t('Microsite'),
      'entity class' => 'MicrositeEntity',
      'controller class' => 'MicrositeEntityController',
      'base table' => 'microsite_entity',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'msid',
        'bundle' => 'type',
      ),
      'bundle keys' => array(
        'bundle' => 'type',
      ),
      'bundles' => array(),
      'load hook' => 'microsite_entity_load',
      'view modes' => array(
        'full' => array(
          'label' => t('Default'),
          'custom settings' => FALSE,
        ),
      ),
      'label callback' => 'entity_class_label',
      'uri callback' => 'entity_class_uri',
      'module' => 'microsite_entity',
      'access callback' => 'microsite_entity_access',
    ),
  );
  $return['microsite_entity_type'] = array(
    'label' => t('Microsite Type'),
    'entity class' => 'MicrositeEntityType',
    'controller class' => 'MicrositeEntityTypeController',
    'base table' => 'microsite_entity_type',
    'fieldable' => FALSE,
    'bundle of' => 'microsite_entity',
    'exportable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'name' => 'type',
      'label' => 'label',
    ),
    'module' => 'microsite_entity',
    // Enable the entity API's admin UI.
    'admin ui' => array(
      'path' => 'admin/structure/microsite-types',
      'file' => 'microsite_entity.admin.inc',
      'controller class' => 'MicrositeEntityTypeUIController',
    ),
    'access callback' => 'microsite_entity_type_access',
  );

  return $return;
}

/**
 * Implements hook_entity_info_alter().
 */
function microsite_entity_entity_info_alter(&$entity_info) {
  foreach (microsite_entity_types() as $type => $info) {
    $entity_info['microsite_entity']['bundles'][$type] = array(
      'label' => $info->label,
      'admin' => array(
        'path' => 'admin/structure/microsite-types/manage/%microsite_entity_type',
        'real path' => 'admin/structure/microsite-types/manage/' . $type,
        'bundle argument' => 4,
      ),
    );
  }
}

/**
 * Implements hook_menu().
 */
function microsite_entity_menu() {
  $items = array();

  $items['microsite/add'] = array(
    'title' => 'Add microsite',
    'page callback' => 'microsite_entity_admin_add_page',
    'access arguments' => array('create microsite_entity entities'),
    'file' => 'microsite_entity.admin.inc',
    'type' => MENU_LOCAL_ACTION,
    'tab_parent' => 'microsite',
    'tab_root' => 'microsite',
  );

  $microsite_uri = 'microsite/%microsite_entity';
  $microsite_uri_argument_position = 1;

  $items[$microsite_uri] = array(
    'title callback' => 'entity_label',
    'title arguments' => array('microsite_entity', $microsite_uri_argument_position),
    'page callback' => 'microsite_entity_view',
    'page arguments' => array($microsite_uri_argument_position),
    'access callback' => 'entity_access',
    'access arguments' => array(
      'view',
      'microsite_entity',
      $microsite_uri_argument_position),
    'file' => 'microsite_entity.pages.inc',
  );

  $items[$microsite_uri . '/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items[$microsite_uri . '/delete'] = array(
    'title' => 'Delete microsite',
    'title callback' => 'microsite_entity_label',
    'title arguments' => array($microsite_uri_argument_position),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('microsite_entity_delete_form', $microsite_uri_argument_position),
    'access callback' => 'entity_access',
    'access arguments' => array(
      'edit',
      'microsite_entity',
      $microsite_uri_argument_position),
    'file' => 'microsite_entity.admin.inc',
  );

  $items[$microsite_uri . '/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('microsite_entity_form', $microsite_uri_argument_position),
    'access callback' => 'entity_access',
    'access arguments' => array(
      'edit',
      'microsite_entity',
      $microsite_uri_argument_position),
    'file' => 'microsite_entity.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );

  foreach (microsite_entity_types() as $type => $info) {
    $items['microsite/add/' . $type] = array(
      'title' => 'Add microsite',
      'page callback' => 'microsite_entity_add',
      'page arguments' => array(2),
      'access callback' => 'entity_access',
      'access arguments' => array('create', 'microsite_entity', $type),
      'file' => 'microsite_entity.admin.inc',
    );
  }

  $items['admin/structure/microsite-types/%microsite_entity_type/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('microsite_entity_type_form_delete_confirm', 4),
    'access arguments' => array('administer microsite_entity types'),
    'weight' => 1,
    'type' => MENU_NORMAL_ITEM,
    'file' => 'microsite_entity.admin.inc',
  );

  $items['hosted/files'] = array(
    'title' => 'File download',
    'page callback' => 'microsite_entity_download',
    'page arguments' => array('hosted'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['integrated/files'] = array(
    'title' => 'File download',
    'page callback' => 'microsite_entity_download',
    'page arguments' => array('integrated'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['microsite_imce/%/%'] = array(
    'title' => 'Microsite File Browser',
    'page callback' => 'microsite_entity_imce',
    'page arguments' => array(1, 2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_enable().
 */
function microsite_entity_enable() {
  $exists = db_query("SELECT link_title FROM {menu_links} WHERE menu_name=:menu_name AND link_title=:link_title", array(':menu_name' => 'menu-ti-editorial-navbar', ':link_title' => 'Microsite'))->fetchField();
  if (!$exists) {
  $item = array( //added microsite menu item to install for .
         'link_title' => 'Microsite',
         'link_path' => 'microsite',
         'menu_name' => 'menu-ti-editorial-navbar',
         'weight' => 3,
         'expanded' => 0,
         'customized' => 1,
        );
  menu_link_save($item);
  }
}

/**
 * Implements hook_permission().
 */
function microsite_entity_permission() {
  $permissions = array(
    'administer microsite_entity types' => array(
      'title' => t('Administer microsite types'),
      'description' => t('Allows users to configure microsite types and their fields.'),
      'restrict access' => TRUE,
    ),
    'create microsite_entity entities' => array(
      'title' => t('Create microsites'),
      'description' => t('Allows users to create microsites.'),
      'restrict access' => TRUE,
    ),
    'view microsite_entity entities' => array(
      'title' => t('View microsites'),
      'description' => t('Allows users to view microsites.'),
      'restrict access' => TRUE,
    ),
    'edit any microsite_entity entities' => array(
      'title' => t('Edit any microsites'),
      'description' => t('Allows users to edit any microsites.'),
      'restrict access' => TRUE,
    ),
    'edit own microsite_entity entities' => array(
      'title' => t('Edit own microsites'),
      'description' => t('Allows users to edit own microsites.'),
      'restrict access' => TRUE,
    ),
  );

  return $permissions;
}


/**
 * Implements hook_entity_property_info_alter().
 */
function microsite_entity_entity_property_info_alter(&$info) {
  $properties = &$info['microsite_entity']['properties'];
  $properties['created'] = array(
    'label' => t("Date created"),
    'type' => 'date',
    'description' => t("The date the node was posted."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer nodes',
    'schema field' => 'created',
  );
  $properties['changed'] = array(
    'label' => t("Date changed"),
    'type' => 'date',
    'schema field' => 'changed',
    'description' => t("The date the node was most recently updated."),
  );
  $properties['uid'] = array(
    'label' => t("Author"),
    'type' => 'user',
    'description' => t("The author of the microsite."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer microsite_entity entities',
    'required' => TRUE,
    'schema field' => 'uid',
  );
}

/**
 * Implements hook_stream_wrappers().
 *
 * hook_stream_wrappers() is Drupal's way of exposing the class that PHP will
 * use to provide a new stream wrapper class. In this case, we'll expose the
 * 'hosted' and 'integrated' schemes, so a file reference like
 * "hosted://example/example.txt" or "integrated://example/example.txt"
 * are readable and writable under the base microsite filepaths.
 */
function microsite_entity_stream_wrappers() {
  $wrappers = array(
    'hosted' => array(
      'name' => t('Hosted Microsite stream wrapper'),
      'class' => 'MicrositeEntityHostedStreamWrapper',
      'description' => t('Store files for a hosted microsite.'),
    ),
    'integrated' => array(
      'name' => t('Integrated Microsite stream wrapper'),
      'class' => 'MicrositeEntityIntegratedStreamWrapper',
      'description' => t('Store files for an integrated microsite.'),
    ),
  );
  return $wrappers;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
//function microsite_entity_form_system_file_system_settings_alter(&$form, &$form_state, $form_id) {
//  $file_hosted_path = array(
//    '#type' => 'textfield',
//    '#title' => 'Hosted Microsite file system path',
//    '#maxlength' => 255,
//    '#weight' => -2,
//    '#default_value' => variable_get('microsite_hosted_path', ''),
//    '#description' => "An existing local file path for storing Hosted Microsite files. It should be writable by Drupal. Paths that begin with '/' are absolute, while paths without a preceding '/' are relative to Drupal's root.",
//    '#after_build' => array('system_check_directory'),
//  );
//  
//  $form['file_hosted_path'] = $file_hosted_path;
//  $file_integrated_path = array(
//    '#type' => 'textfield',
//    '#title' => 'Integrated Microsite file system path',
//    '#maxlength' => 255,
//    '#default_value' => variable_get('microsite_integrated_path', ''),
//    '#weight' => -1,
//    '#description' => "An existing local file path for storing Integrated Microsite files. It should be writable by Drupal. Paths that begin with '/' are absolute, while paths without a preceding '/' are relative to Drupal's root.",
//    '#after_build' => array('system_check_directory'),
//  );
//  $form['#submit'][] = 'microsite_entity_form_system_file_system_settings_submit';
//  $form['file_integrated_path'] = $file_integrated_path;
//}

/**
 * Additional submit handler for the media file-systems form.
 *
 * This will save Microsite filesystems.
 *
 * @param array $form
 *   The form variable.
 * @param array $form_state
 *   The form_state.
 */
function microsite_entity_form_system_file_system_settings_submit($form, &$form_state) {
  $values = $form_state['values'];
  if (!empty($values['file_integrated_path'])) {
    variable_set('microsite_integrated_path', $values['file_integrated_path']);
  }
  if (!empty($values['file_hosted_path'])) {
    variable_set('microsite_hosted_path', $values['file_hosted_path']);
  }
}

/**
 * Implements hook_field_formatter_info().
 */
function microsite_entity_field_formatter_info() {
  return array(
    'microsites_file_table' => array(
      'label' => t('Microsite files table'),
      'field types' => array('file'),
    ),
  );
}
/**
 * Implements hook_field_formatter_view().
 */
function microsite_entity_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  switch ($display['type']) {
    case 'microsites_file_table':
      if (!empty($items)) {
        // Display all values in a single element..
        $element[0] = array(
          '#theme' => 'microsites_file_formatter_table',
          '#items' => $items,
        );
      }
      break;
  }

  return $element;
}

/**
 * Implements hook_theme().
 */
function microsite_entity_theme() {
  return array(
    'microsites_file_formatter_table' => array(
      'variables' => array('items' => NULL),
    ),
  );
}

/**
 * Menu handler for Microsite file transfers.
 *
 * Call modules that implement hook_file_download() to find out if a file is
 * accessible and what headers it should be transferred with. If one or more
 * modules returned headers the download will start with the returned headers.
 * If a module returns -1 drupal_access_denied() will be returned. If the file
 * exists but no modules responded drupal_access_denied() will be returned.
 * If the file does not exist drupal_not_found() will be returned.
 */
function microsite_entity_download() {
  // Merge remainder of arguments from GET['q'], into relative file path.
  $args = func_get_args();
  $scheme = array_shift($args);
  $target = implode('/', $args);
  $uri = $scheme . '://' . $target;
  if (file_stream_wrapper_valid_scheme($scheme) && file_exists($uri)) {
    // Let other modules provide headers and controls access to the file.
    // module_invoke_all() uses array_merge_recursive() which merges header
    // values into a new array. To avoid that and allow modules to override
    // headers instead, use array_merge() to merge the returned arrays.
    $headers = array();
    foreach (module_implements('file_download') as $module) {
      $function = $module . '_file_download';
      $result = $function($uri);
      if ($result == -1) {
        // Throw away the headers received so far.
        $headers = array();
        break;
      }
      if (isset($result) && is_array($result)) {
        $headers = array_merge($headers, $result);
      }
    }
    if (count($headers)) {
      file_transfer($uri, $headers);
    }
    drupal_access_denied();
  }
  else {
    drupal_not_found();
  }
  drupal_exit();
}


/**
 * Implements hook_file_download().
 */
function microsite_entity_file_download($uri) {
  $x = array();
  $x['Content-Type'] = file_get_mimetype($uri);

  return $x;
}

/*******************************************************************************
 * ***************************** Microsite API's *******************************
 * *****************************************************************************
 */

/**
 * Access callback for microsite.
 */
function microsite_entity_access($op, $microsite, $account = NULL, $entity_type = NULL) {
  global $user;

  if (!isset($account)) {
    $account = $user;
  }
  switch ($op) {
    case 'create':
      return user_access('administer microsite_entity entities', $account)
          || user_access('create microsite_entity entities', $account);
    case 'view':
      return user_access('administer microsite_entity entities', $account)
          || user_access('view microsite_entity entities', $account);
    case 'edit':
      return user_access('administer microsite_entity entities')
          || user_access('edit any microsite_entity entities')
          || (user_access('edit own microsite_entity entities') && ($microsite->uid == $account->uid));
  }
}

/**
 * Load a microsite.
 */
function microsite_entity_load($msid, $reset = FALSE) {
  $microsite = microsite_entity_load_multiple(array($msid), array(), $reset);
  return reset($microsite);
}

/**
 * Load multiple microsites based on certain conditions.
 */
function microsite_entity_load_multiple($msids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('microsite_entity', $msids, $conditions, $reset);
}

/**
 * Save microsite.
 */
function microsite_entity_save($microsite) {
  $result = TRUE;

  $allfields = field_info_field_map();
  $ourfields = array_intersect_key($allfields, (array) $microsite);

  /* Create a directory to hold files for this microsite,
   * assuming it doesn't already exist.
   */
  if ($microsite->type == 'hosted_microsite') {
    $scheme_prefix = "hosted://";
  }
  elseif ($microsite->type == 'integrated_microsite') {
    $scheme_prefix = "integrated://";
  }
  else {
    $scheme_prefix = "public://";
  }
  $dir_fragment = microsite_entity_munge_directory_name($microsite->title);
  if (!$dir_fragment) {
    drupal_set_message(t('Invalid microsite name. The microsite could not be saved.'), 'error');
    $result = FALSE;
  }
  else {
    $dir = $scheme_prefix . $dir_fragment;
    file_prepare_directory($dir, FILE_CREATE_DIRECTORY);

    foreach ($ourfields as $field => $info) {
      if ($info['type'] == 'file' && isset($microsite->$field)) {
        foreach ($microsite->$field as $lang => $file_item) {
          foreach ($file_item as $delta => $file) {
            $microsite->{$field}[$lang][$delta]['display'] = 1;
          }
        }
      }
    }
    entity_save('microsite_entity', $microsite);
  }

  return $result;
}

/**
 * Delete single microsite.
 */
function microsite_entity_delete($microsite) {
  entity_delete('microsite_entity', entity_id('microsite_entity', $microsite));
}

/**
 * Delete multiple microsites.
 */
function microsite_entity_delete_multiple($microsite_ids) {
  entity_delete_multiple('microsite_entity', $microsite_ids);
}


/*******************************************************************************
 * ************************** Microsite Type API's *****************************
 * *****************************************************************************
 */

/**
 * Access callback for microsite Type.
 */
function microsite_entity_type_access($op, $entity = NULL) {
  return user_access('administer microsite_entity types');
}

/**
 * Load microsite Type.
 */
function microsite_entity_type_load($microsite_type) {
  return microsite_entity_types($microsite_type);
}

/**
 * List of microsite Types.
 */
function microsite_entity_types($type_name = NULL) {
  $types = entity_load_multiple_by_name('microsite_entity_type', isset($type_name) ? array($type_name) : FALSE);
  return isset($type_name) ? reset($types) : $types;
}

/**
 * Save microsite type entity.
 */
function microsite_entity_type_save($microsite_type) {
  entity_save('microsite_entity_type', $microsite_type);
}

/**
 * Delete single case type.
 */
function microsite_entity_type_delete($microsite_type) {
  entity_delete('microsite_entity_type', entity_id('microsite_entity_type', $microsite_type));
}

/**
 * Delete multiple case types.
 */
function microsite_entity_type_delete_multiple($microsite_type_ids) {
  entity_delete_multiple('microsite_entity_type', $microsite_type_ids);
}

/**
 * Implements hook_views_api().
 */
function microsite_entity_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'microsite_entity'),
  );
}

/**
 * Application-specific implementation of the IMCE 'page'.
 *
 * @param string $scheme
 *   ex.: hosted
 * @param string $root
 *   root directory path for the scheme.
 */
function microsite_entity_imce($scheme = NULL, $root = NULL) {
  $stuff = '';
  if (module_exists('admin_menu')) {
    // Suppress admin_menu.
    module_invoke('admin_menu', 'suppress');
  }
  $jsop = isset($_GET['jsop']) ? $_GET['jsop'] : NULL;
  drupal_add_http_header('Content-Type', 'text/html; charset=utf-8');
  if (module_exists('imce')) {
    $pth = drupal_get_path('module', 'imce') . '/inc/imce.page.inc';
    require_once $pth;
    $stuff = imce_page($GLOBALS['user'], $scheme, $jsop);
  }
  print $stuff;
  exit();
}

/**
 * Implements hook_file_presave().
 */
function microsite_entity_file_presave($file) {
  $result = TRUE;
  if (!empty($file)) {
    $uri = $file->uri;
    $uri_bits = parse_url($uri);
    if ($uri_bits['scheme'] == 'hosted') {
      $url = file_create_url($uri);
      $path = drupal_realpath($uri);
      // @TODO  Possibly add file to field table.
      foreach (module_implements('hosted_file_validate') as $module) {
        $function = $module . '_hosted_file_validate';
        $result = $result & $function($file);
      }
      if (!$result) {
        // This file failed validation - notify user.
        $msg = t("Uploaded file !filename failed validation and should be removed.", array('!filename' => $file->filename));
        watchdog('MICROSITE', $msg, NULL, WATCHDOG_ALERT);
        drupal_set_message(check_plain($msg), 'warning');
      }
    }
  }
}

/**
 * Implements hook_hosted_file_validate().
 */
function microsite_entity_hosted_file_validate($file) {
  $result = TRUE;
  if (!empty($file)) {
    $uri = $file->uri;
    $uri_bits = parse_url($uri);
    if ($uri_bits['scheme'] == 'hosted') {
      $url = file_create_url($uri);
      $path = drupal_realpath($uri);
      // @TODO  add checks for file validity (security, other) here.
      // Return FALSE if the file fails validation.
      // If validation fails, at least add a watchdog message saying why
    }
  }

  return $result;
}

/**
 * Implements hook_file_delete().
 */
function microsite_entity_file_delete($file) {
  if (!empty($file)) {
    $uri = $file->uri;
    $uri_bits = parse_url($uri);
    if ($uri_bits['scheme'] == 'hosted') {
      $url = file_create_url($uri);
      $path = drupal_realpath($uri);
      // @TODO  Possibly to delete file from field table as well.
    }
  }
}

/**
 * Change a directory name to replace all non-alphanumeric with a '-'.
 *
 * The returned string will have a maximum length defined by system variable
 * microsite_entity_max_dirname_length, with a default of 64.
 *
 * @param string $orig_name
 *   The string to be munged.
 *
 * @return string
 *   The munged string.
 */
function microsite_entity_munge_directory_name($orig_name) {
  $phase_1 = preg_replace('/(\W)+/', '-', $orig_name);
  $phase_2 = preg_split('/(\W)+$/', $phase_1);
  $max_dirname_length = variable_get('microsite_entity_max_dirname_length', 64);
  $munged_name = substr(strtolower($phase_2[0]), 0, $max_dirname_length);

  return $munged_name;
}

/**
 * Implements hook_menu_alter().
 */
function microsite_entity_menu_alter(&$items) {
  // If the microsites view is not present and enabled, don't add this item.
  if (module_exists('views')) {
    $view = views_get_view('microsites');
    if (isset($view) && !$view->disabled) {
      $items['admin/microsite'] = array(
        'title'           => 'Microsites',
        'description'     => t('List and/or add Microsites'),
        'menu_name'       => 'management',
        'weight'          => -9,
        'access callback' => TRUE,
        'page callback'   => 'drupal_goto',
        'page arguments' => array('microsite'),
        'access arguments' => array('view microsite_entity'),
        'type' => MENU_NORMAL_ITEM,
      );
    }
  }
}

/**
 * Implements hook_field_attach_presave().
 */
function microsite_entity_field_attach_presave($entity_type, $entity) {
  if ($entity_type == 'microsite_entity' && $entity->type == 'hosted_microsite') {
    $files = array();
    $filedir = "hosted://" . microsite_entity_munge_directory_name($entity->title);
    $query = db_select('file_managed', 'fm');
    $query->condition('uri', $filedir . '%', 'LIKE');
    $query->fields('fm');
    $result = $query->execute();
    // Make sure these files are associated with the proper entity.
    while ($record = $result->fetchAssoc()) {
      $files[] = array(
        'fid' => $record['fid'],
        'display' => 1,
        'description' => '',
      );
    }
    $fieldstuff = array('und' => $files);

    // Contrariwise, remove the file usage for IMCE, since that's just an
    // implementation artifact that's not relevant or useful, and actually
    // prevents the file from being deleted if need be.
    foreach ($files as $file) {
      $query2 = db_delete('file_usage');
      $query2->condition('fid', $file['fid']);
      $query2->condition('module', 'imce');
      $query2->condition('type', 'file');
      $query2->execute();
    }

    $entity->field_hosted_file_assets = $fieldstuff;
  }
}

/**
 * Implements hook_admin_paths().
 */
function microsite_entity_admin_paths() {
  $paths = array(
    'microsite' => TRUE,
    'microsite/*' => TRUE,
  );
  return $paths;
}

/**
 * Implements hook_taxonomy_term_view().
 */
function microsite_entity_taxonomy_term_view($term, $view_mode, $langcode) {
  if ($term->vocabulary_machine_name == 'hosted_microsite_tags') {
    $url = url('microsite' . '/' . $term->vocabulary_machine_name . '/' . $term->name);
    drupal_goto($url);
  }
}
